<?php

//@TODO: create Schema syntax for object database creation

namespace Logos\DB\MySQL;

include_once "db-interface.php";
include_once "db-core.php";
include_once "db-config.php";
include_once "cache/phpfastcache.php";

use Logos\DB\DatabaseHandler;
use Logos\Main\DatabaseCore;
use Logos\Main\Config;
use Logos\Main;
use PDO;
use PDOException;
use DateTime;
use Exception;

abstract class DatabaseObject implements DatabaseHandler{

    public $id;

    public function __construct($id = null){

       $this->classDataSetup($id);

    }

    /**
     * Handles the object loading from the database when an ID is passed
     * @param mixed $id [optional]
     * <p>Can be an array of matched object data, the object ID, an object, or even a json string</p>
     * @return void
     */
    public function classDataSetup($id = null){

        if(!isset($this->loaded))
           $this->loaded = false;

        if($id !== null){

            if(is_numeric($id)){

                $this->loadInto($id);
                $this->loaded = true;

            }else{

                $this->updateObject(self::dataToArray($id));

            }
        }
    }

    //-------------DB Object Creation

    /**
     * Create a new object in database with data based on current given object<br/><br/>
     *
     * 100 Queries Run
     * <p>Average Time: 140ms per 100/488kb</p>
     * <p>Average Time: 7ms per 1/10kb</p>
     * <p>Average Time: 9ms per 2/11kb</p>
     *
     * @return Object $this
     */
    public function createNew(){

        //A list of keys to be iterated though, generated by Object Attribute Names
        //We use the keychain because it gets non-dynamic property names, which is what the database schema is based on.
        $keyChain = self::getKeyChain();

        $dataArray = [];

        $prepareStatement = "INSERT INTO ".self::name()." (";

        foreach($keyChain as $key => $val){

            //since this is a new object, we don't want to save the ID, rather letting the DB generate an ID
            if($this->{$key} !== null && $key !== "id")
                $prepareStatement .= "$key, ";
            else
                unset($keyChain[$key]);

        }

        $prepareStatement = rtrim($prepareStatement, ", ").") VALUES (";

        //we are going to generate the array of variables to be processed by PDO
        //in example, color and count will be overwritten by PDO safely

        foreach($keyChain as $key => $val){

            $prepareStatement .= ":$key, ";

            $dataArray[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($this->{$key}) : $this->{$key};

        }

        $prepareStatement = rtrim($prepareStatement, ", ").")";

        //at this point, the array should be good to go
        //INSERT INTO fruit (color, count) VALUES (:color, :count)

        //checks to see if there was an object that was inserted into the database
        $this->id = Core::fetchQuery($prepareStatement, $dataArray, false) ? Core::getInstance()->dbh->lastInsertId() : null;

        return $this;
    }

    /**
     * Static version of createNew, creates a single object in a databased with given $data<br/><br/>
     * <p>The difference between this and the calling create on a new instance of an object is that
     * createSingle has ability to not have to create an empty object, thus giving us a lower memory
     * count and a much lower execution time.</p>
     *
     * 100 Queries Run
     * <p>Average Time: 112ms per 100/337kb</p>
     * <p>Average Time: 6ms per 1/12kb</p>
     * <p>Average Time: 11ms per 2/15kb</p>
     * <br/>
     * self::newInstance($data)->createNew()
     * <p>Average Time: 149ms per 100/522kb</p>
     * <p>Average Time: 11ms per 1/15kb</p>
     * <p>Average Time: 12ms per 2/16kb</p>
     *
     * @param mixed $data
     * <p>Can be an array of matched object data, an object, or even a json string</p>
     *
     * @return mixed $data
     * <p>Returns either the data array plus the object ID or false if the object failed to be inserted into the database</p>
     *
     * @throws exception if the data is not in a readable/convertible format
     */
    public static function createSingle($data){

        self::dataToArray($data);

        $keyChain = self::getKeyChain();
        $dataArray = [];

        $prepareStatement = "INSERT INTO ".self::name()." (";

        foreach($data as $key => $val){

            //Here we check to see if the key meets our criteria. If it doesn't we want to unset the key so
            //don't have to sort through the $data array again, and make the same comparisons.
            if($val !== null && $keyChain[$key] !== "id" && array_key_exists($key, $keyChain))
                $prepareStatement .= "$key, ";
            else
                unset($data[$key]);

        }

        $prepareStatement = rtrim($prepareStatement, ", ").") VALUES (";

        foreach($data as $key => $val){
            $prepareStatement .= ":$key, ";

            //If an object has the word date in it, we want to convert it to a usable mysql format
            $dataArray[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;
        }

        $prepareStatement = rtrim($prepareStatement, ", ").")";

        if(Core::fetchQuery($prepareStatement, $dataArray, false)){

            $data["id"] = Core::getInstance()->dbh->lastInsertId();

            return $data;

        }

        return false;

    }


    /**
     * CreateMultiple is useful if you want to create multiple numbers of objects with a single query. It is
     * recommended that you use it for creating anything greater then 1 object, as its efficiency is about equal
     * to CreateSingle, even with a single query. It however, requires that the first array/object in data
     * have all of the fields that you want to insert, because it uses this object as the basis to build the query.
     * Any fields outside of the first array in $data will not be added, and likewise, the fields which don't
     * exist for some arrays but do for the first one will be set to NULL
     *
     * 100 Queries Run
     * <p>Average Time: 30ms per 100/81kb</p>
     *
     * @param Array $data
     * <p>Can be an array of matched object data, an array of objects, or even an array of json strings.
     * It is recommended that all of the arrays inside $data be symmetrical.</p>
     *
     * @param mixed $count
     * <p>Can be an array of matched object data, an object, or even a json string</p>
     *
     * @return boolean
     * <p>Returns the result of query execute. If the execute was successful, then returns true. False on fail</p>
     *
     * @trigger_error on incorrect $data format or if $data is given and not an array of arrays, and count is not given.
     */
    public static function createMultiple($data, $count = null){

        $keyChain = self::getKeyChain();

        $prepareStatement = "INSERT INTO ".self::name()." (";

        //Good keys contains the keys of the first object that match variables of the called object.
        $goodKeys = $dataArray = [];

        if($count === null && !isset($data[0])){
            //If $data was a single object array but count was 0, we set count to 1 to try and execute query.
            //We can trigger an error here for malformed data, but if only one object was passed as data,
            //we want to treat it as a single query and try and execute due to the dynamic nature of the web.
            $count = 1;
        }

        //This creates a uniform data set to convert and set our remaining data to.
        //By skipping this we would have to create longer routes for data to travel, which would be less efficient.
        if($count !== null && !isset($data[0])){

            $temp = $data;
            unset($data);
            $data = [$temp];

        }

        //We go through each bit of data and make sure that its usable for our query builder below
        //Meaning, that all data is in the array state. This is time consuming, so its recommended to use arrays
        //for each data set.
        foreach($data as $objID => $obj){

            self::dataToArray($data[$objID]);

        }

        //This is for generating
        //  INSERT INTO example
        //      (example_id, name, value, other_value)
        //As mentioned in the class description, arrays inside $data should NOT be asymmetric.
        foreach(array_keys ($data[0]) as $value){

            if($value !== "id" && array_key_exists($value, $keyChain)){
                $goodKeys[$value] = true;
                $prepareStatement .= "$value, ";
            }

        }

        $prepareStatement = rtrim($prepareStatement, ", ").") VALUES ";

        //If the number of queries are based on the count of $data instead of smearing a single object
        //across multiple objects inside a database.
        if($count === null){

            foreach($data as $objID => $obj){

                $prepareStatement .= " (";

                foreach($goodKeys as $key => $val){

                    //This check is important because it makes sure we have an even number of parameters for each object
                    if(!isset($data[$objID][$key]))
                        $data[$objID][$key] = null;

                    if(array_key_exists($key, $goodKeys)){
                        $prepareStatement .= ":$key$objID, ";

                        $dataArray[':'.$key.$objID] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($data[$objID][$key]) : $data[$objID][$key];
                    }

                }

                $prepareStatement = rtrim($prepareStatement, ", ")."), ";

            }

        }else{

            $obj = $data[0];

            while($count > 0){

                $prepareStatement .= " (";

                foreach($obj as $key => $val){

                    if(array_key_exists($key, $goodKeys)){
                        $prepareStatement .= ":$key$count, ";

                        $dataArray[':'.$key.$count] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;
                    }

                }

                $prepareStatement = rtrim($prepareStatement, ", ")."), ";

                $count--;

            }

        }

        $prepareStatement = rtrim($prepareStatement, ", ");

        return Core::fetchQuery($prepareStatement, $dataArray, false);

    }

    //-------------DB Object Update

    /**
     * Updates/saves changes to an object in the database, with an optional param $changedData.
     * If changedData is null, then it will just use what data is in the class. If you however want to just change
     * a few things and already have an object, then use the changed data param
     *
     * 100 Queries Run
     * <p>Average Time: 136ms per 100/611kb</p>
     * <p>Average Time: 7ms per 1/12kb</p>
     * <p>Average Time: 9ms per 2/14kb</p>
     *
     * @param mixed $changedData [optional]
     * <p>An optional array/object/json string of data that is to be saved into the database relating to the
     * referenced object</p>
     *
     * @return boolean
     * <p>Returns the result of query execute. If the execute was successful, then returns true. False on fail</p>
     *
     * @throws Exception
     * <p>If the ID of the object is not set. If the ID of the object isn't known, the use the static method</p>
     */
    public function save($changedData = null){

        if($this->id === null)
            throw new Exception("Object has no ID, so cannot be saved using a non-static method.");

        $keyChain = self::getKeyChain();
        $dataArray = [];

        self::dataToArray($changedData);

        $prepareStatement = "UPDATE ".self::name()." SET ";

        foreach($changedData as $key => $val){
            if($val !== null && $key !== "id" && array_key_exists($key, $keyChain))
                $prepareStatement .= "$key = :$key, ";
            else
                unset($changedData[$key]);
        }

        $prepareStatement = rtrim($prepareStatement, ", ")." WHERE id = :id";

        $changedData["id"] = $this->id;

        foreach($changedData as $key => $val){

            $dataArray[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;

        }

        //string should look like this:
        //UPDATE fruit SET color = :color, count = :count WHERE id = :id

        Core::fetchQuery($prepareStatement, $dataArray, false);

        return $this;

    }

    public static function saveMultiple($changedData, $conditionArray){

        $keyChain = self::getKeyChain();

        self::dataToArray($changedData);
        self::dataToArray($conditionArray);

        $prepareStatement = "UPDATE ".self::name()." SET ";

        foreach($changedData as $key => $val){
            if($val !== null && $key !== "id" && array_key_exists($key, $keyChain))
                $prepareStatement .= "$key = :$key, ";
            else
                unset($changedData[$key]);
        }

        $prepareStatement = rtrim($prepareStatement, ", ")." WHERE ";

        foreach($conditionArray as $key => $value){

            if(array_key_exists($key, $keyChain)){
                $prepareStatement .= "{$key} = :w{$key}, ";
                $changedData["w".$key] = $value;
            }

        }

        foreach($changedData as $key => $val){

            $changedData[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;

            unset($changedData[$key]);

        }

        //string should look like this:
        //UPDATE fruit SET color = :color, count = :count WHERE id = :id

        return Core::fetchQuery($prepareStatement, $changedData, false);

    }


    //-------------DB Load Objects

    public function loadInto($id){

        $prepareStatement = "SELECT * FROM ".self::name()." WHERE id = :id LIMIT 1";
        $dataArray = [":id" => $id];

        return Core::fetchQueryObj($prepareStatement, $dataArray, PDO::FETCH_INTO, $this);

    }

    public function getList($conditionArray = null){

        $keyChain = self::getKeyChain();
        $name = self::name();

        $prepareStatement = "SELECT * FROM ".$name." WHERE ";

        if($conditionArray !== null){
            foreach($conditionArray as $key => $value){

                if(array_key_exists($key, $keyChain)){
                    $prepareStatement .= "{$key} = :{$key}, ";
                    $conditionArray[":".$key] = $value;
                }

                unset($conditionArray[$key]);

            }

            $prepareStatement = rtrim($prepareStatement, ", ");

        }

        $objects = Core::fetchQueryObj($prepareStatement, $conditionArray, PDO::FETCH_CLASS, $name);

        if(is_array($objects)){
            foreach($objects as &$value){
                $value->loaded = true;
            }
        }

        return $objects;

    }

    public static function load($conditionArray){

        $keyChain = self::getKeyChain();

        $prepareStatement = "SELECT * FROM ".self::name()." WHERE ";

        foreach($conditionArray as $key => $value){

            if(array_key_exists($key, $keyChain)){
                $prepareStatement .= "{$key} = :{$key}, ";
                $conditionArray[":".$key] = $value;
            }

            unset($conditionArray[$key]);

        }

        $prepareStatement = rtrim($prepareStatement, ", ")." LIMIT 1";
        $name = self::name();

        return Core::fetchQueryObj($prepareStatement, $conditionArray, PDO::FETCH_OBJ, $name);

    }

    //Static version of getList
    public static function loadMultiple($conditionArray = null){
        return self::newInstance()->getList($conditionArray);
    }

    //-------------DB Delete Objects

    public function remove(){
       return self::destroy($this->id);
    }

    public static function removeMultiple($conditionArray){

        $keyChain = self::getKeyChain();

        $prepareStatement = "DELETE FROM ".self::name()." WHERE ";

        foreach($conditionArray as $key => $value){

            if(array_key_exists($key, $keyChain)){
                $prepareStatement .= "{$key} = :{$key}, ";
                $conditionArray[":".$key] = $value;
            }

            unset($conditionArray[$key]);

        }

        $prepareStatement = rtrim($prepareStatement, ", ");

        return Core::fetchQuery($prepareStatement, $conditionArray);

    }

    public static function destroy($id){

        $prepareStatement = "DELETE FROM ".self::name()." WHERE id = :id";
        $dataArray = [':id' => $id];

        return Core::fetchQuery($prepareStatement, $dataArray);

    }

    //-------------DB Caching Functions

    //caches the object
    // phpFastCache support "apc", "memcache", "memcached", "wincache" ,"files", "sqlite" and "xcache"
    public function cache($cache_name, $timer = 600){

        phpFastCache("files")->set($cache_name, $this, $timer);

        return $this;

    }

    //finds a cached object or queries the database with a given condition
    public static function find($cacheName, $conditionArray){

        $obj = phpFastCache("files")->get($cacheName);

        if($obj === null)
            $obj = self::load($conditionArray);

        return $obj;

    }


    //-------------Object Related

    //gets the first object occurrence or creates a new one in the database
    public static function firstOrCreate($dataArray){

        $obj = self::firstOrNew($dataArray);

        if(!is_numeric($obj->id))
            $obj->createNew();

        return $obj;

    }

    //gets the first object occurrence or returns a new instance of that object
    public static function firstOrNew($dataArray){

        $obj = self::load($dataArray);

        if(!is_object($obj))
            $obj = self::newInstance($dataArray);

        return $obj;

    }

    private static function name(){

        $className = explode("\\", get_called_class());

        return end($className);

    }

    //returns an instance of an object with a given array of data
    public static function newInstance($dataArray = null){

        $className = get_called_class();

        return new $className($dataArray);

    }

    //User::query('limit', 10)->getList();
    //User::query(['orderBy', 'limit'], ['id DESC', 10])->getList();
    //User::query(['orderBy', 'limit'], ['id ASC, username DESC', 10])->getList();

    public static function query($functionCall, $params){

        if(!is_array($functionCall))
            Core::getInstance()->query->$functionCall($params);
        else{
            foreach($functionCall as $key => $value){
                Core::getInstance()->query->$value($params[$key]);
            }
        }

        return self::newInstance();
    }


    private static function getKeyChain(){

        return get_class_vars(get_called_class());

    }

    public function toArray(){

        return get_object_vars($this->prune());

    }

    private static function dataToArray(&$dataToFilter){

        if(!is_array($dataToFilter)){
            if(is_object($dataToFilter))
                $dataToFilter = (array) $dataToFilter;
            else if(Main\isJson($dataToFilter))
                $dataToFilter = json_decode($dataToFilter, true);
            else
                trigger_error("Tried to filter Malformed data");
        }

        return $dataToFilter;

    }

    public function prune(){

        if(isset($this->loaded))
            unset($this->loaded);

        return $this;

    }

    public function updateObject($array){

        $keyChain = self::getKeyChain();

        self::dataToArray($array);

        foreach($array as $key => $value){
            if(array_key_exists($key, $keyChain))
                $this->{$key} = $value;
        }

        return $this;
    }

    //Magic Methods
    //serialize
    public function __sleep(){

        $keys = self::getKeyChain();

        $temp = [];

        foreach($keys as $key => $value){
            if($this->{$key} !== null)
                array_push($temp, $key);
        }

        return $temp;

    }

    public function __toString(){

        return json_encode($this->toArray(), JSON_FORCE_OBJECT);

    }

    public function __invoke($dataArray){

        $object = self::name();

        return new $object($dataArray);

    }

}

class QueryHandler{

    private $query = "";

    //Any time a query is executed, we want to make sure to clear the query so that it doesn't show up again.
    public function getQuery(){

        $tempQ = $this->query;

        $this->query = "";

        return $tempQ;

    }

    public function groupBy($grouping){

        $this->query = " GROUP BY $grouping".$this->query;

        return $this;

    }

    public function orderBy($order){

        $this->query .= " ORDER BY $order";

        return $this;

    }

    public function limit($min = 1, $max = null){

        $this->query .= " LIMIT ";

        $this->query .= "$min, ";

        if($max !== null)
            $this->query .= "$max, ";


        $this->query = rtrim($this->query, ", ");

        return $this;

    }

}

//Core is a singleton because it implements the database connection class. Calling core multiple times
//would otherwise create many more objects then if we didn't have a singleton as a core.
//Also, creating a singleton means we can save data to the query using our query handler
//between instance calls.
class Core implements DatabaseCore{

    public $dbh;
    public $query;
    private static $instance;
    //Core is a singleton

    public function __construct(){

        $dsn = 'mysql:host=' . Config::read('db.host') .
            ';dbname='    . Config::read('db.base') .
            ';connect_timeout=15';

        $this->dbh = @new PDO($dsn, Config::read('db.user'), Config::read('db.password'), array(PDO::ATTR_PERSISTENT => true));
        $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); //PDO::ERRMODE_SILENT
        $this->dbh->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);

        $this->query = new QueryHandler();

    }

    //Singleton get class
    public static function getInstance(){
        if (!isset(self::$instance)){
            $object = __CLASS__;
            self::$instance = new $object;
        }

        return self::$instance;
    }

    public static function fetchQuery($prepare, $execute, $returnQuery = true){

        try {

            $newInstance = self::getInstance();

            $query = $newInstance->dbh->prepare($prepare.$newInstance->query->getQuery());

            if(!$returnQuery)
                return $query->execute($execute);
            else
                $query->execute($execute);

            return $query;

        }catch(PDOException $pe) {
            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);
        }

        return false;

    }

    public static function fetchQueryObj($prepare, $execute, $fetchMode, &$fetchParam){

        try {

            $newInstance = self::getInstance();

            $query = $newInstance->dbh->prepare($prepare.$newInstance->query->getQuery());

            $query->setFetchMode($fetchMode, $fetchParam);
            $query->execute($execute);

            if($fetchMode === PDO::FETCH_OBJ){

                $fetchParam = $query->fetchObject($fetchParam);

                if(!is_object($fetchParam) && !is_array($fetchParam))
                    return false;

                $fetchParam->loaded = true;

            }else if($fetchMode === PDO::FETCH_INTO){

                $query->fetch();

                $fetchParam->loaded = true;

            }else if($fetchMode === PDO::FETCH_CLASS){

                return $query->fetchAll($fetchMode, 'Logos\Objects\\'.$fetchParam);

            }

            return $fetchParam;


        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;

    }


}

?>