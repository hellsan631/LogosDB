<?php

    //@TODO: create Schema syntax for object database creation
    //@TODO: rest of DatabaseObject functions

    namespace Logos\DB\MySQL;

    include_once "db-interface.php";
    include_once "db-core.php";
    include_once "db-config.php";

    use Logos\DB\DatabaseHandler;
    use Logos\Main\DatabaseCore;
    use Logos\Main\Config;
    use Logos\Main;
    use PDO;
    use PDOException;
    use DateTime;
    use Exception;

    abstract class DatabaseObject implements DatabaseHandler{

        public $id;

        //Force Extending class to define this method
        //abstract protected function classDataSetup();

        public function __construct($id = null){

           $this->classDataSetup($id);

        }


        /**
         * Handles the object loading from the database when an ID is passed
         * @param mixed $id [optional]
         * <p>Can be an array of matched object data, the object ID, an object, or even a json string</p>
         * @return void
         */
        public function classDataSetup($id = null){

            if(!isset($this->loaded))
               $this->loaded = false;
            if(!isset($this->hasDate))
                $this->hasDate = false;

            if($id !== null){

                if(is_numeric($id)){
                    $this->loadInto($id);
                }else{

                    if(is_array($id)){}
                    else if(is_object($id))
                        $id = get_object_vars($id);
                    else if(Main\isJson($id))
                        $id = json_decode($id, true);

                    $this->updateObject($id);
                    $this->loaded = true;

                }
            }
        }

        //-------------DB Object Creation

        /**
         * Create a new object in database with data based on current given object<br/><br/>
         *
         * 100 Queries Run
         * <p>Average Time: 170ms per 100/522kb</p>
         *
         * @return Object $this
         */
        public function createNew(){

            //A list of keys to be iterated though, generated by Object Attribute Names
            //We use the keychain because it gets non-dynamic property names, which is what the database schema is based on.
            $keyChain = self::getKeyChain();

            //Beginning of building the prepared MYSQL insert statement
            $prepareStatement = "INSERT INTO ".self::name()." (";

            foreach($keyChain as $key => $val){

                //since this is a new object, we don't want to save the ID, rather letting the DB generate an ID
                //We also don't want a variable that is null to be included in the list
                if($this->{$key} !== null && $key !== "id")
                    $prepareStatement .= "$key, ";
                else
                    unset($keyChain[$key]);

            }

            $prepareStatement = rtrim($prepareStatement, ", ");
            $prepareStatement .= ") VALUES (";

            foreach($keyChain as $key => $val){

                $prepareStatement .= ":$key, ";

            }

            $prepareStatement = rtrim($prepareStatement, ", ");
            $prepareStatement .= ")";

            //at this point, the array should be good to go
            //INSERT INTO fruit (color, count) VALUES (:color, :count)
            //we are going to generate the array of variables to be processed by PDO
            //in example, color and count will be overwritten by PDO safely
            //to learn more, refer to PDO manual for more information on specific PDO procedures

            //An empty dataArray to dump our keychain data in
            $dataArray = [];

            foreach ($keyChain as $key => $val) {

                if(isset($this->hasDate) && $this->hasDate === true && mb_strpos($key,'date') !== false)
                    $dataArray[':'.$key] = Main\unixToMySQL($this->{$key});
                else
                    $dataArray[':'.$key] = $this->{$key};

            }

            if(Core::getQuery($prepareStatement, $dataArray, false)){ //checks to see if there was an object that was inserted into the database
                $this->id = Core::getInstance()->dbh->lastInsertId();
            }

            return $this;
        }

        /**
         * Static version of createNew, creates a single object in a databased with given $data<br/><br/>
         * <p>The difference between this and the calling create on a new instance of an object is that
         * createSingle has ability to not have to create an empty object, thus giving us a lower memory
         * count and a much lower execution time. $returnObject should ideally be kept to false</p>
         *
         * 100 Queries Run
         * <p>Average Time: 122ms per 100/337kb</p>
         * <br/>
         * self::returnInstance($data)->createNew()
         * <p>Average Time: 192ms per 100/588kb</p>
         *
         * @param mixed $data
         * <p>Can be an array of matched object data, an object, or even a json string</p>
         *
         * @param boolean $returnObject [optional]
         * <p>If return object is specified and true, then createSingle will return a new object with given data.
         * If its false, it will return the new rows data as an associated array, with the ID of the object added</p>
         *
         * @return mixed $data
         *
         * @throws exception if the data is not in a readable/convertible format
         */
        public static function createSingle($data, $returnObject = false){

            if(!is_array($data)){
                if(is_object($data))
                    $data = (array) $data;
                else if(Main\isJson($data))
                    $data = json_decode($data, true);
                else
                    throw new Exception("Object Creation Data is Malformed (cannot be converted to an array)");
            }

            $keyChain = self::getKeyChain();

            //Beginning of building the prepared MYSQL insert statement
            $prepareStatement = "INSERT INTO ".self::name()." (";

            foreach($data as $key => $val){

                //Since this is a new object, we don't want to save the ID, rather letting the DB generate an ID
                //We also don't want a variable that is null to be included in the list
                if($val !== null && $keyChain[$key] !== "id" && array_key_exists($key, $keyChain))
                    $prepareStatement .= "$key, ";
                else
                    unset($data[$key]);

            }

            $prepareStatement = rtrim($prepareStatement, ", ");
            $prepareStatement .= ") VALUES (";

            //No checking needed here because all of the keys which didn't check out last time were unset
            foreach($data as $key => $val){
                $prepareStatement .= ":$key, ";
            }

            $prepareStatement = rtrim($prepareStatement, ", ");
            $prepareStatement .= ")";

            $dataArray = [];

            foreach ($data as $key => $val) {

                //We can't skip the date checking because we don't know if an object has the hasDate field as that field
                //is dynamically declared upon object creation.
                if(mb_strpos($key,'date') !== false)
                    $dataArray[':'.$key] = Main\unixToMySQL($val);
                else
                    $dataArray[':'.$key] = $val;

            }

            //checks to see if there was an object that was inserted into the database
            if(Core::getQuery($prepareStatement, $dataArray, false)){

                $data["id"] = Core::getInstance()->dbh->lastInsertId();

                if($returnObject){
                    return self::returnInstance($data);
                }

                return $data;

            }

            return false;

        }


        public static function createMultiple($data, $count = null){

            //  INSERT INTO example
            //      (example_id, name, value, other_value)
            //  VALUES
            //      (100, 'Name 1', 'Value 1', 'Other 1'),
            //      (101, 'Name 2', 'Value 2', 'Other 2'),
            //      (102, 'Name 3', 'Value 3', 'Other 3'),
            //      (103, 'Name 4', 'Value 4', 'Other 4');

        }


        //-------------DB Object Update

        //Updates/saves changes to an object in the database, with an optional param $changedData
        public function save($changedData){}

        //Updates multiple objects with given data, and a conditional array
        public static function saveMultiple($changedData, $conditionArray){}


        //-------------DB Load Objects

        //Loads a single object from the database
        public static function load($conditionArray){}

        //Loads a file into an object
        public function loadInto($id){}

        //Loads a list of objects from the database with given conditions
        public static function getList($conditionArray){}


        //-------------DB Delete Objects

        //Deletes/Removes/Erases a single object
        public function remove(){}

        //Deletes/Removes/Erases multiple objects based on a set of conditions
        public static function removeMultiple($conditionArray){}

        //Deletes/Removes/Erases a based on an ID (can be an array)
        public static function destroy($id){}


        //-------------DB Caching Functions

        //caches the object
        public function cache($cache_name, $timer){}

        //finds a cached object or database
        public static function find($conditionArray){}


        //-------------Object Related

        //gets the first object occurrence or creates a new one in the database
        public static function firstOrCreate($dataArray){}

        //gets the first object occurrence or returns a new instance of that object
        public static function firstOrNew($dataArray){}

        public static function name(){

            $className = explode("\\", get_called_class());

            return mb_strtolower(end($className));

        }

        //returns an instance of an object with a given array of data
        public static function returnInstance($dataArray = null){

            $className = get_called_class();

            return new $className($dataArray);

        }


        private static function getKeyChain(){

            return get_class_vars(get_called_class());

        }

        public function toArray(){

            return get_object_vars($this->prune());

        }

        public function prune(){

            if(isset($this->hasDate))
                unset($this->hasDate);

            if(isset($this->loaded))
                unset($this->loaded);

            return $this;

        }

        public function updateObject($array){
            $keyChain = self::getKeyChain();

            if(is_object($array))//converts (json) stdClass Object to an array
                $array = (array) $array;

            if(!is_array($array)){
                if(Main\isJson($array))
                    $array = json_decode($array, true);
                else
                    return $this;
            }


            foreach($array as $key => $value){

                if(array_key_exists($key, $keyChain)){

                    if(isset($this->hasDate) && $this->hasDate === true && mb_strpos($key,'date') !== false){

                        if($value instanceof DateTime || Main\isValidDateTimeString($value))
                            $this->{$key} =  Main\unixToMySQL($value);
                        else
                            $this->{$key} =  Main\unixToMySQL("now");

                    }else
                        $this->{$key} = $value;

                }

            }

            return $this;
        }

        //grabs a json string and converts it to the object

        //Magic Methods
        //serialize
        public function __sleep(){

            return $this->toArray();

        }

        public function __toString(){

            return json_encode($this->toArray(), JSON_FORCE_OBJECT);

        }

        public function __invoke($dataArray){

            $object = get_class($this);

            return new $object($dataArray);

        }

    }

    class Core implements DatabaseCore{

        public $dbh;
        private static $instance;

        public function __construct(){

            $dsn = 'mysql:host=' . Config::read('db.host') .
                ';dbname='    . Config::read('db.base') .
                ';connect_timeout=15';

            $this->dbh = @new PDO($dsn, Config::read('db.user'), Config::read('db.password'), array(PDO::ATTR_PERSISTENT => true));
            $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); //PDO::ERRMODE_SILENT
            $this->dbh->setAttribute(PDO::ATTR_EMULATE_PREPARES, true);

        }

        public static function getInstance(){
            if (!isset(self::$instance)){
                $object = __CLASS__;
                self::$instance = new $object;
            }

            return self::$instance;
        }

        public static function getQuery($prepare, $execute, $returnQuery = true){

            try {

                $query = self::getInstance()->dbh->prepare($prepare);

                if(!$returnQuery)
                    return $query->execute($execute);
                else
                    $query->execute($execute);

                return $query;

            }catch(PDOException $pe) {
                trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);
            }

            return false;

        }

    }

?>