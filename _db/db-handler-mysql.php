<?php

    //@TODO: create Schema syntax for object database creation
    //@TODO: rest of DatabaseObject functions

    namespace Logos\DB\MySQL;

    //error_reporting(E_STRICT);

    include_once "db-interface.php";
    include_once "db-core.php";
    include_once "db-config.php";

    use Logos\DB\DatabaseHandler;
    use Logos\Main\DatabaseCore;
    use Logos\Main\Config;
    use Logos\Main;
    use PDO;
    use PDOException;
    use DateTime;
    use Exception;

    abstract class DatabaseObject implements DatabaseHandler{

        public $id;

        //Force Extending class to define this method
        //abstract protected function classDataSetup();

        public function __construct($id = null){

           $this->classDataSetup($id);

        }

        /**
         * Handles the object loading from the database when an ID is passed
         * @param mixed $id [optional]
         * <p>Can be an array of matched object data, the object ID, an object, or even a json string</p>
         * @return void
         */
        public function classDataSetup($id = null){

            if(!isset($this->loaded))
               $this->loaded = false;

            if($id !== null){

                if(is_numeric($id)){

                    $this->loadInto($id);
                    $this->loaded = true;

                }else{

                    $this->updateObject(self::dataToArray($id));

                }
            }
        }

        //-------------DB Object Creation

        /**
         * Create a new object in database with data based on current given object<br/><br/>
         *
         * 100 Queries Run
         * <p>Average Time: 140ms per 100/488kb</p>
         * <p>Average Time: 7ms per 1/10kb</p>
         * <p>Average Time: 9ms per 2/11kb</p>
         *
         * @return Object $this
         */
        public function createNew(){

            //A list of keys to be iterated though, generated by Object Attribute Names
            //We use the keychain because it gets non-dynamic property names, which is what the database schema is based on.
            $keyChain = self::getKeyChain();

            //An empty dataArray to dump our data in
            $dataArray = [];

            //Beginning of building the prepared MYSQL insert statement
            $prepareStatement = "INSERT INTO ".self::name()." (";

            foreach($keyChain as $key => $val){

                //since this is a new object, we don't want to save the ID, rather letting the DB generate an ID
                //We also don't want a variable that is null to be included in the list
                if($this->{$key} !== null && $key !== "id")
                    $prepareStatement .= "$key, ";
                else
                    unset($keyChain[$key]);

            }

            $prepareStatement = rtrim($prepareStatement, ", ").") VALUES (";

            //we are going to generate the array of variables to be processed by PDO
            //in example, color and count will be overwritten by PDO safely
            //to learn more, refer to PDO manual for more information on specific PDO procedures

            foreach($keyChain as $key => $val){

                $prepareStatement .= ":$key, ";

                $dataArray[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($this->{$key}) : $this->{$key};

            }

            $prepareStatement = rtrim($prepareStatement, ", ").")";

            //at this point, the array should be good to go
            //INSERT INTO fruit (color, count) VALUES (:color, :count)

            //checks to see if there was an object that was inserted into the database
            $this->id = Core::getQuery($prepareStatement, $dataArray, false) ? Core::getInstance()->dbh->lastInsertId() : null;

            return $this;
        }

        /**
         * Static version of createNew, creates a single object in a databased with given $data<br/><br/>
         * <p>The difference between this and the calling create on a new instance of an object is that
         * createSingle has ability to not have to create an empty object, thus giving us a lower memory
         * count and a much lower execution time.</p>
         *
         * 100 Queries Run
         * <p>Average Time: 112ms per 100/337kb</p>
         * <p>Average Time: 6ms per 1/12kb</p>
         * <p>Average Time: 11ms per 2/15kb</p>
         * <br/>
         * self::newInstance($data)->createNew()
         * <p>Average Time: 149ms per 100/522kb</p>
         * <p>Average Time: 11ms per 1/15kb</p>
         * <p>Average Time: 12ms per 2/16kb</p>
         *
         * @param mixed $data
         * <p>Can be an array of matched object data, an object, or even a json string</p>
         *
         * @return mixed $data
         * <p>Returns either the data array plus the object ID or false if the object failed to be inserted into the database</p>
         *
         * @throws exception if the data is not in a readable/convertible format
         */
        public static function createSingle($data){

            self::dataToArray($data);

            $keyChain = self::getKeyChain();

            $dataArray = [];

            $prepareStatement = "INSERT INTO ".self::name()." (";

            foreach($data as $key => $val){

                if($val !== null && $keyChain[$key] !== "id" && array_key_exists($key, $keyChain))
                    $prepareStatement .= "$key, ";
                else
                    unset($data[$key]);

            }

            $prepareStatement = rtrim($prepareStatement, ", ").") VALUES (";

            //No checking needed here because all of the keys which didn't check out last time were unset
            foreach($data as $key => $val){
                $prepareStatement .= ":$key, ";

                //We can't skip the date checking because we don't know if an object has the hasDate field as that field
                //is dynamically declared upon object creation.
                $dataArray[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;
            }

            $prepareStatement = rtrim($prepareStatement, ", ").")";

            //checks to see if there was an object that was inserted into the database
            if(Core::getQuery($prepareStatement, $dataArray, false)){

                $data["id"] = Core::getInstance()->dbh->lastInsertId();

                return $data;

            }

            return false;

        }


        /**
         * CreateMultiple is useful if you want to create a multiple numbers of objects with a single query. It is
         * recommended that you use it for creating anything greater then 1 object, as its efficiency is about equal
         * to CreateSingle, even with a single query.It however, requires that the first array/object in data
         * have all of the fields that you want to insert, because it uses this object as the basis to build the query.
         * Any fields outside of the first array in $data will not be added, and likewise, the fields which don't
         * exist for some arrays but do for the first one will be set to NULL
         *
         * 100 Queries Run
         * <p>Average Time: 30ms per 100/81kb</p>
         *
         * @param Array $data
         * <p>Can be an array of matched object data, an array of objects, or even an array of json strings.
         * It is recommended that all of the arrays inside $data be symmetrical.</p>
         *
         * @param mixed $count
         * <p>Can be an array of matched object data, an object, or even a json string</p>
         *
         * @return boolean
         * <p>Returns the result of query execute. If the execute was successful, then returns true. False on fail</p>
         *
         * @trigger_error on incorrect $data format or if $data is given and not an array of arrays, and count is not given.
         */
        public static function createMultiple($data, $count = null){

            $keyChain = self::getKeyChain();

            $prepareStatement = "INSERT INTO ".self::name()." (";

            //  INSERT INTO example
            //      (example_id, name, value, other_value)
            //  VALUES
            //      (100, 'Name 1', 'Value 1', 'Other 1'),
            //      (101, 'Name 2', 'Value 2', 'Other 2'),
            //      (102, 'Name 3', 'Value 3', 'Other 3'),
            //      (103, 'Name 4', 'Value 4', 'Other 4');

            //Good keys contains the keys of the first object that match variables of the called object.
            $goodKeys = $dataArray = [];

            if($count === null && !isset($data[0])){
                //If $data was a single object array but count was 0, we set count to 1 to try and execute query.
                //We can trigger an error here for malformed data, but if only one object was passed as data,
                //we want to treat it as a single query and try and execute due to the dynamic nature of the web.
                $count = 1;
            }

            //This creates a uniform data set to convert and set our remaining data to.
            //By skipping this we would have to create longer routes for data to travel, which would be less efficient.
            if($count !== null && !isset($data[0])){

                $temp = $data;
                unset($data);
                $data = [$temp];

            }

            //We go through each bit of data and make sure that its usable for our query builder below
            //Meaning, that all data is in the array state. This is time consuming, so its recommended to use arrays
            //for each data set.
            foreach($data as $objID => $obj){

                self::dataToArray($data[$objID]);

            }

            //This is for generating
            //  INSERT INTO example
            //      (example_id, name, value, other_value)
            //As mentioned in the class description, arrays inside $data should NOT be asymmetric.
            foreach(array_keys ($data[0]) as $value){

                if($value !== "id" && array_key_exists($value, $keyChain)){
                    $goodKeys[$value] = true;
                    $prepareStatement .= "$value, ";
                }

            }

            $prepareStatement = rtrim($prepareStatement, ", ").") VALUES ";

            //If the number of queries are based on the count of $data instead of smearing a single object
            //across multiple objects inside a database.
            if($count === null){

                //going through each object/array inside $data
                foreach($data as $objID => $obj){

                    $prepareStatement .= " (";

                    foreach($goodKeys as $key => $val){

                        //We check to see if the data on the given key is set, otherwise set it to null.
                        if(!isset($data[$objID][$key]))
                            $data[$objID][$key] = null;

                        if(array_key_exists($key, $goodKeys)){
                            $prepareStatement .= ":$key$objID, ";

                            $dataArray[':'.$key.$objID] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($data[$objID][$key]) : $data[$objID][$key];
                        }

                    }

                    $prepareStatement = rtrim($prepareStatement, ", ")."), ";

                }

            }else{

                $obj = $data[0];

                while($count > 0){

                    $prepareStatement .= " (";

                    foreach($obj as $key => $val){

                        if(array_key_exists($key, $goodKeys)){
                            $prepareStatement .= ":$key$count, ";

                            //We can't skip the date checking because we don't know if an object has the hasDate field as that field
                            //is dynamically declared upon object creation.
                            $dataArray[':'.$key.$count] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;
                        }

                    }

                    $prepareStatement = rtrim($prepareStatement, ", ")."), ";

                    $count--;

                }

            }

            $prepareStatement = rtrim($prepareStatement, ", ");

            return Core::getQuery($prepareStatement, $dataArray, false);

        }

        //-------------DB Object Update

        /**
         * Updates/saves changes to an object in the database, with an optional param $changedData.
         * If changedData is null, then it will just use what data is in the class. If you however want to just change
         * a few things and already have an object, then use the changed data param
         *
         * 100 Queries Run
         * <p>Average Time: 136ms per 100/611kb</p>
         * <p>Average Time: 7ms per 1/12kb</p>
         * <p>Average Time: 9ms per 2/14kb</p>
         *
         * @param mixed $changedData [optional]
         * <p>An optional array/object/json string of data that is to be saved into the database relating to the
         * referenced object</p>
         *
         * @return boolean
         * <p>Returns the result of query execute. If the execute was successful, then returns true. False on fail</p>
         *
         * @throws Exception
         * <p>If the ID of the object is not set. If the ID of the object isn't known, the use the static method</p>
         */
        public function save($changedData = null){

            if($this->id === null)
                throw new Exception("Object has no ID, so cannot be saved using a non-static method.");

            $keyChain = self::getKeyChain();
            $dataArray = [];

            self::dataToArray($changedData);

            $prepareStatement = "UPDATE ".self::name()." SET ";

            foreach($changedData as $key => $val){
                if($val !== null && $key !== "id" && array_key_exists($key, $keyChain))
                    $prepareStatement .= "$key = :$key, ";
                else
                    unset($changedData[$key]);
            }

            $prepareStatement = rtrim($prepareStatement, ", ")." WHERE id = :id";

            $changedData["id"] = $this->id;

            foreach($changedData as $key => $val){

                $dataArray[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;

            }

            //string should look like this:
            //UPDATE fruit SET color = :color, count = :count WHERE id = :id

            Core::getQuery($prepareStatement, $dataArray, false);

            return $this;

        }

        //Updates multiple objects with given data, and a conditional array
        public static function saveMultiple($changedData, $conditionArray){

            $keyChain = self::getKeyChain();

            self::dataToArray($changedData);
            self::dataToArray($conditionArray);

            $prepareStatement = "UPDATE ".self::name()." SET ";

            foreach($changedData as $key => $val){
                if($val !== null && $key !== "id" && array_key_exists($key, $keyChain))
                    $prepareStatement .= "$key = :$key, ";
                else
                    unset($changedData[$key]);
            }

            $prepareStatement = rtrim($prepareStatement, ", ")." WHERE ";

            foreach($conditionArray as $key => $value){

                if(array_key_exists($key, $keyChain)){
                    $prepareStatement .= "{$key} = :w{$key}, ";
                    $changedData["w".$key] = $value;
                }

            }

            foreach($changedData as $key => $val){

                $changedData[':'.$key] = (mb_strpos($key,'date') !== false) ? Main\unixToMySQL($val) : $val;

                unset($changedData[$key]);

            }

            //string should look like this:
            //UPDATE fruit SET color = :color, count = :count WHERE id = :id

            return Core::getQuery($prepareStatement, $changedData, false);

        }


        //-------------DB Load Objects

        //Loads a file into an object
        public function loadInto($id){

            $prepareStatement = "SELECT * FROM ".self::name()." WHERE id = :id LIMIT 1";
            $dataArray = [":id" => $id];

            return Core::fetchQuery($prepareStatement, $dataArray, PDO::FETCH_INTO, $this);

        }

        //Loads a single object from the database
        public static function load($conditionArray){

            $keyChain = self::getKeyChain();

            $prepareStatement = "SELECT * FROM ".self::name()." WHERE ";

            foreach($conditionArray as $key => $value){

                if(array_key_exists($key, $keyChain)){
                    $prepareStatement .= "{$key} = :{$key}, ";
                    $conditionArray[":".$key] = $value;
                }

                unset($conditionArray[$key]);

            }

            $prepareStatement = rtrim($prepareStatement, ", ")." LIMIT 1";

            return Core::fetchQuery($prepareStatement, $conditionArray, PDO::FETCH_OBJ, self::name());

        }

        //Loads a list of objects from the database with given conditions
        public static function getList($conditionArray){

            $keyChain = self::getKeyChain();

            $prepareStatement = "SELECT * FROM ".self::name()." WHERE ";

            foreach($conditionArray as $key => $value){

                if(array_key_exists($key, $keyChain)){
                    $prepareStatement .= "{$key} = :{$key}, ";
                    $conditionArray[":".$key] = $value;
                }

                unset($conditionArray[$key]);

            }

            $prepareStatement = rtrim($prepareStatement, ", ")." LIMIT 10";
            $name = self::name();

            $objects = Core::fetchQuery($prepareStatement, $conditionArray, PDO::FETCH_CLASS, $name);

            if(is_array($objects)){
                foreach($objects as &$value){
                    $value->loaded = true;
                }
            }

            return $objects;

        }


        //-------------DB Delete Objects

        //Deletes/Removes/Erases a single object
        public function remove(){}

        //Deletes/Removes/Erases multiple objects based on a set of conditions
        public static function removeMultiple($conditionArray){}

        //Deletes/Removes/Erases a based on an ID (can be an array)
        public static function destroy($id){}


        //-------------DB Caching Functions

        //caches the object
        public function cache($cache_name, $timer){}

        //finds a cached object or database
        public static function find($conditionArray){}


        //-------------Object Related

        //gets the first object occurrence or creates a new one in the database
        public static function firstOrCreate($dataArray){}

        //gets the first object occurrence or returns a new instance of that object
        public static function firstOrNew($dataArray){}

        private static function name(){

            $className = explode("\\", get_called_class());

            return end($className);

        }

        //returns an instance of an object with a given array of data
        public static function newInstance($dataArray = null){

            $className = get_called_class();

            return new $className($dataArray);

        }


        private static function getKeyChain(){

            return get_class_vars(get_called_class());

        }

        public function toArray(){

            return get_object_vars($this->prune());

        }

        private static function dataToArray(&$dataToFilter){

            if(!is_array($dataToFilter)){
                if(is_object($dataToFilter))
                    $dataToFilter = (array) $dataToFilter;
                else if(Main\isJson($dataToFilter))
                    $dataToFilter = json_decode($dataToFilter, true);
                else
                    trigger_error("Tried to filter Malformed data");
            }

            return $dataToFilter;

        }

        public function prune(){

            if(isset($this->loaded))
                unset($this->loaded);

            return $this;

        }

        public function updateObject($array){

            $keyChain = self::getKeyChain();

            $array = self::dataToArray($array);

            foreach($array as $key => $value){
                if(array_key_exists($key, $keyChain))
                    $this->{$key} = $value;
            }

            return $this;
        }

        //grabs a json string and converts it to the object

        //Magic Methods
        //serialize
        public function __sleep(){

            return $this->toArray();

        }

        public function __toString(){

            return json_encode($this->toArray(), JSON_FORCE_OBJECT);

        }

        public function __invoke($dataArray){

            $object = get_class($this);

            return new $object($dataArray);

        }

    }

    class Core implements DatabaseCore{

        public $dbh;
        private static $instance;

        public function __construct(){

            $dsn = 'mysql:host=' . Config::read('db.host') .
                ';dbname='    . Config::read('db.base') .
                ';connect_timeout=15';

            $this->dbh = @new PDO($dsn, Config::read('db.user'), Config::read('db.password'), array(PDO::ATTR_PERSISTENT => true));
            $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); //PDO::ERRMODE_SILENT
            $this->dbh->setAttribute(PDO::ATTR_EMULATE_PREPARES, true);

        }

        public static function getInstance(){
            if (!isset(self::$instance)){
                $object = __CLASS__;
                self::$instance = new $object;
            }

            return self::$instance;
        }

        public static function getQuery($prepare, $execute, $returnQuery = true){

            try {

                $query = self::getInstance()->dbh->prepare($prepare);

                if(!$returnQuery)
                    return $query->execute($execute);
                else
                    $query->execute($execute);

                return $query;

            }catch(PDOException $pe) {
                trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);
            }

            return false;

        }

        public static function fetchQuery($prepare, $execute, $fetchMode, &$fetchParam){

            try {

                $query = self::getInstance()->dbh->prepare($prepare);


                $query->setFetchMode($fetchMode, $fetchParam);


                $query->execute($execute);

                if($fetchMode === PDO::FETCH_OBJ){

                    $fetchParam = $query->fetchObject($fetchParam);

                    if(!is_object($fetchParam) && !is_array($fetchParam))
                        return false;

                    $fetchParam->loaded = true;

                }else if($fetchMode === PDO::FETCH_INTO){

                    $query->fetch();

                    $fetchParam->loaded = true;

                }else if($fetchMode === PDO::FETCH_CLASS){

                    return $query->fetchAll($fetchMode, 'Logos\Objects\\'.$fetchParam);

                }

                return $fetchParam;


            }catch(PDOException $pe) {

                trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

            }

            return false;

        }


    }

?>