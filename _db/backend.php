<?php

if(!session_id()) {
    @session_start();
} else {

}

//@TODO create serialize function for objects
//@TODO change functions to use $options array instead of long constructors
//@TODO add the ability to change sorting
//@TODO getNext should be 1 object only, getNextList should handle pagination
//@TODO add new functions getPrevious, getPreviousList
//@TODO continue commenting
//@TODO modular file structure
//@TODO DatabaseObject's __construct should accept a data array of the object's attributes

class Config{
	static $confArray;

	public static function read($name){
		return self::$confArray[$name];
	}

	public static function write($name, $value){
		self::$confArray[$name] = $value;
	}

}

abstract class DatabaseObject{

    protected $className;
    public $id;

    //Force Extending class to define this method
    //abstract protected function classDataSetup();

    public function __construct($id = null){

        $this->classDataSetup();

        if(is_array($id)){

            if($this->toObject($id) === false)
                throw new Exception("Object failed to set new variables");

        }else if($id !== null){

            $this->load($id, null, 1, false);

        }

    }

    protected function classDataSetup(){
        $this->className = get_class($this);
    }

    // Common methods

    /**
     * Saves a Database Object
     *
     * @return Boolean true/false based on success of DB insert
     * @throws PDO error if database is unreachable
     */
    public function save(){
        //a list of keys to be iterated though, generated by Object Attribute Names
        $keyChain = $this->getKeyChain();

        //beginning of building the prepared MYSQL insert statement
        $prepareStatement = "INSERT INTO {$this->className} (";

        foreach($keyChain as $val){
            if($val != "id"){
                //since this is a new object, we don't want to save the ID, rather letting the DB generate an ID
                $prepareStatement .= "$val, ";
            }
        }

        $prepareStatement = rtrim($prepareStatement, ", ");
        $prepareStatement .= ") VALUES (";

        foreach($keyChain as $val){
            if($val != "id"){
                $prepareStatement .= ":$val, ";
            }
        }

        $prepareStatement = rtrim($prepareStatement, ", ");
        $prepareStatement .= ")";

        //at this point, the array should be good to go
        //INSERT INTO fruit (color, count) VALUES (:color, :count)
        //we are going to generate the array of variables to be processed by PDO
        //in example, color and count will be overwritten by PDO safely
        //to learn more, refer to PDO manual for more information on specific PDO procedures

        $executeArray = array();

        //our data is gotten from the iterateVisible class
        $dataArray = $this->toArray();

        foreach ($keyChain as $val) {
            if($val != "id"){
                $executeArray[':'.$val] = $dataArray[$val];
            }
        }

        try {

            //getting PDO connection and preparing the statement
            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);
            //running the statement with object variables
            $query->execute($executeArray);

            if($query->rowCount() > 0){ //checks to see if there was an object that was inserted into the database
                $this->id = $pdo->dbh->lastInsertId();
                return true;
            }

            return false;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;
    }

    /**
     * Updates an Database Object
     *
     * @deprecated
     */
    public function saveNew(){
        return $this->save();
    }

    /**
     * Updates an Database Object
     * @param String $identifier, if an ID isn't being used to update an object, the WHERE clause would go here
     * @return Boolean true/false based on success of DB insert
     * @throws PDO error if database is unreachable
     */
    public function update($identifier = null){
        $keyChain = $this->getKeyChain();

        $prepareStatement = "UPDATE {$this->className} SET ";

        foreach($keyChain as $val){
            if($val != "id"){
                $prepareStatement .= "$val = :$val, ";
            }
        }

        $prepareStatement = rtrim($prepareStatement, ", ");


        if($identifier != null){

            foreach($keyChain as $value){

                if(stristr($identifier, $value) !== false){

                    $prepareStatement .= " WHERE {$value} = :{$value}";

                }
            }
        }else{
            $prepareStatement .= " WHERE id = :id";
        }

        $executeArray = array();

        $dataArray = $this->toArray();

        foreach ($keyChain as $val) {
            $executeArray[':'.$val] = $dataArray[$val];
        }

        //string should look like this:
        //UPDATE fruit SET color = :color, count = :count WHERE id = :id

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            $query->execute($executeArray);

            if($query->rowCount() > 0){
                return true;
            }

            return false;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;

    }

    /**
     * Updates an Database Object
     *
     * @deprecated
     */
    public function saveOld(){
        return $this->update();
    }

    public function erase(){

        $prepareStatement = "DELETE FROM {$this->className} WHERE id = :id";
        $executeArray = array(':id' => $this->id);

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            $query->execute($executeArray);

            if($query->rowCount() > 0){
                return true;
            }

            return false;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;

    }


    //data is the thing to be checked, (1, pizza)
    //type is the name of the thing in the DB, (id, food_name)
    //limit is the number of returned results
    //return_object is if the object should be loaded into the current object, or if it should return a new instance.
    public function load($data, $type = null, $limit = 1, $return_object = true){

        //a list of keys to be iterated though, generated by Object Attribute Names
        $keyChain = $this->getKeyChain();
        $condition = null;
        $prepareStatement = "SELECT * FROM {$this->className} WHERE ";
        $execArray = null;

        if(is_array($data)){

            $condition = array();
            $execArray = array();

            if(is_array($type)){

                foreach($type as $value){
                    foreach($keyChain as $val){

                        if(stristr($value, $val) !== false){
                            array_push($condition, $val);
                        }

                        if(stristr($value, 'password') !== false){
                            array_push($condition, null);
                        }
                    }
                }

            }else if($type != null){

                for($i = 1; $i < count ($data); $i++){
                    array_push($condition, $type);
                }

            }else{
                for($i = 1; $i < count ($data); $i++){
                    array_push($condition, 'id');
                }
            }

            $count = 0;

            foreach($condition as $value){

                foreach($keyChain as $val){

                    if(stristr($value, 'password') !== false){
                        return false;
                    }

                    if($val == 'id'){

                        if($value == $val){
                            $prepareStatement .= "{$val} = :var$count OR ";
                            $execArray[":var$count"] = "$data[$count]";
                            $count++;
                        }

                    }else if(stristr($value, $val) !== false){
                        $prepareStatement .= "{$val} = :var$count OR ";
                        $execArray[":var$count"] = "$data[$count]";
                        $count++;
                    }

                }

            }

            $prepareStatement = rtrim($prepareStatement, " OR ");

            $prepareStatement .= " LIMIT $limit";

        }else{ //if data is not an array
            if($type !== null){
                foreach($keyChain as $val){

                    if(stristr($type, $val) !== false){
                        $condition = $val;
                        break;
                    }

                    if(stristr($type, 'password') !== false){
                        $condition = null;
                        break;
                    }

                }

            }else{
                $condition = 'id';
            }

            $prepareStatement .= " {$condition} = :var";

            $execArray = array(':var' => $data);
        }


        if($condition === null || $execArray === null){
            return false;
        }

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            $query->execute($execArray);

            if($query->rowCount() == 0){
                return false;
            }

            if($return_object){

                $newInstance = $query->fetchObject($this->className);

                if(!is_object($newInstance) && !is_array($newInstance)){
                    return false;
                }

                return $newInstance;

            }else if($return_object === false){

                $query->setFetchMode(PDO::FETCH_INTO, $this);
                $query->execute();
                $query->fetch();
                $query->closeCursor();

            }


        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;
    }

    /**
     * Loads an object with a given ID
     * Since its deprecated, this is only going to handle a single ID var.
     *
     * @deprecated
     */
    public function loadInstance($id){
        return $this->load($id);
    }

    public function getNext($last_id){

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare("SELECT * FROM {$this->className} WHERE id = (SELECT MIN(id) FROM {$this->className} WHERE id > :last_id)");

            $query->execute(array(':last_id' => $last_id));

            $newInstance = $query->fetchObject($this->className);

            if(!is_object($newInstance)){
                return false;
            }

            return $newInstance;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;
    }

    /**
     * Loads an object with a given ID
     *
     * @deprecated
     */
    public function getNextInstance($last_id){
        return $this->getNext($last_id);
    }


    public function getList($sorting = null, $condition = null){

        $prepareStatement = "SELECT * FROM {$this->className}";
        $conditionValue = null;

        if($condition != null){
            $keyChain = $this->getKeyChain();

            foreach($keyChain as $value){

                if(stristr($condition, $value) !== false){

                    $prepareStatement .= " WHERE {$value} = :{$value}";

                    $conditionValue = $value;

                }
            }
        }

        if($sorting != null){

            $keyChain = $this->getKeyChain();

            foreach($keyChain as $value){

                if(stristr($sorting, $value) !== false){

                    if(stristr($sorting, 'asc') !== false){

                        $prepareStatement .= " ORDER BY {$value} ASC";

                    }else if(stristr($sorting, 'desc') !== false){

                        $prepareStatement .= " ORDER BY {$value} DESC";

                    }else{

                        $prepareStatement .= " ORDER BY {$value} DESC";

                    }
                }
            }
        }

        try {

            $pdo = Core::getInstance();
            $query = $pdo->dbh->prepare($prepareStatement);

            if($condition != null){
                $query->execute(array(":{$conditionValue}" => explode(" = ", $condition)));
            }else{
                $query->execute();
            }

            $objects = $query->fetchAll(PDO::FETCH_CLASS, $this->className);

            if($objects === false){
                return false;
            }

            return $objects;

        }catch(PDOException $pe) {

            trigger_error('Could not connect to MySQL database. ' . $pe->getMessage() , E_USER_ERROR);

        }

        return false;
    }

    private function getKeyChain(){

        $array = array();
        $count = 0;

        foreach($this as $key => $value) {

            if($key != "className"){
                $array[$count++] = $key;
            }

        }

        unset($count);

        return $array;

    }

    public function toArray(){

        $array = array();

        foreach($this as $key => $value) {

            if($key != "className"){
                $array[$key] = $value;
            }
        }

        return $array;
    }

    public function toObject($array){

        foreach($array as $key => $value){

            if(!isset($this->{$key})){
                unset($array[$key]);
            }else if($key !== "className")
                $this->{$key} = $value;

        }

        foreach($this as $key => $value) {

            if($this->{$key} !== $array[$key] && $key !== "className")
                return false;

        }

        return true;

    }

}


class Core{

	public $dbh;
	private static $instance;

	public function __construct(){

		$dsn = 'mysql:host=' . Config::read('db.host') .
			';dbname='    . Config::read('db.base') .
			';connect_timeout=15';

		$this->dbh = new PDO($dsn, Config::read('db.user'), Config::read('db.password'), array(PDO::ATTR_PERSISTENT => true));
		$this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
		$this->dbh->setAttribute(PDO::ATTR_EMULATE_PREPARES, true);
	}

	public static function getInstance(){
		if (!isset(self::$instance)){
			$object = __CLASS__;
			self::$instance = new $object;
		}

		return self::$instance;
	}

    public static function clean($data){
        return htmlspecialchars(mysql_real_escape_string($data));
    }

}

?>